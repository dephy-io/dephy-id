/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */

import {
  combineCodec,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type ReadonlyAccount,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/web3.js';
import { PRODUCT_PROGRAM_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export type CreateDeviceInstruction<
  TProgram extends string = typeof PRODUCT_PROGRAM_PROGRAM_ADDRESS,
  TAccountProgramPda extends string | IAccountMeta<string> = string,
  TAccountPayer extends string | IAccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TAccountToken2022Program extends string | IAccountMeta<string> = string,
  TAccountAtaProgram extends
    | string
    | IAccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  TAccountDephyIdProgram extends string | IAccountMeta<string> = string,
  TAccountVendor extends string | IAccountMeta<string> = string,
  TAccountProductMint extends string | IAccountMeta<string> = string,
  TAccountOwner extends string | IAccountMeta<string> = string,
  TAccountDevice extends string | IAccountMeta<string> = string,
  TAccountProductAtoken extends string | IAccountMeta<string> = string,
  TAccountDeviceMint extends string | IAccountMeta<string> = string,
  TAccountDeviceAtoken extends string | IAccountMeta<string> = string,
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountProgramPda extends string
        ? WritableAccount<TAccountProgramPda>
        : TAccountProgramPda,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            IAccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountToken2022Program extends string
        ? ReadonlyAccount<TAccountToken2022Program>
        : TAccountToken2022Program,
      TAccountAtaProgram extends string
        ? ReadonlyAccount<TAccountAtaProgram>
        : TAccountAtaProgram,
      TAccountDephyIdProgram extends string
        ? ReadonlyAccount<TAccountDephyIdProgram>
        : TAccountDephyIdProgram,
      TAccountVendor extends string
        ? ReadonlyAccount<TAccountVendor>
        : TAccountVendor,
      TAccountProductMint extends string
        ? ReadonlyAccount<TAccountProductMint>
        : TAccountProductMint,
      TAccountOwner extends string
        ? ReadonlyAccount<TAccountOwner>
        : TAccountOwner,
      TAccountDevice extends string
        ? ReadonlyAccount<TAccountDevice>
        : TAccountDevice,
      TAccountProductAtoken extends string
        ? WritableAccount<TAccountProductAtoken>
        : TAccountProductAtoken,
      TAccountDeviceMint extends string
        ? WritableAccount<TAccountDeviceMint>
        : TAccountDeviceMint,
      TAccountDeviceAtoken extends string
        ? WritableAccount<TAccountDeviceAtoken>
        : TAccountDeviceAtoken,
      ...TRemainingAccounts,
    ]
  >;

export type CreateDeviceInstructionData = {
  discriminator: number;
  challenge: number;
};

export type CreateDeviceInstructionDataArgs = { challenge: number };

export function getCreateDeviceInstructionDataEncoder(): Encoder<CreateDeviceInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', getU8Encoder()],
      ['challenge', getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: 1 })
  );
}

export function getCreateDeviceInstructionDataDecoder(): Decoder<CreateDeviceInstructionData> {
  return getStructDecoder([
    ['discriminator', getU8Decoder()],
    ['challenge', getU8Decoder()],
  ]);
}

export function getCreateDeviceInstructionDataCodec(): Codec<
  CreateDeviceInstructionDataArgs,
  CreateDeviceInstructionData
> {
  return combineCodec(
    getCreateDeviceInstructionDataEncoder(),
    getCreateDeviceInstructionDataDecoder()
  );
}

export type CreateDeviceInput<
  TAccountProgramPda extends string = string,
  TAccountPayer extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountToken2022Program extends string = string,
  TAccountAtaProgram extends string = string,
  TAccountDephyIdProgram extends string = string,
  TAccountVendor extends string = string,
  TAccountProductMint extends string = string,
  TAccountOwner extends string = string,
  TAccountDevice extends string = string,
  TAccountProductAtoken extends string = string,
  TAccountDeviceMint extends string = string,
  TAccountDeviceAtoken extends string = string,
> = {
  /** The program derived address of the program account to create (seeds: ['Program']) */
  programPda: Address<TAccountProgramPda>;
  /** The account paying for the storage fees */
  payer: TransactionSigner<TAccountPayer>;
  /** The system program */
  systemProgram?: Address<TAccountSystemProgram>;
  /** The SPL Token 2022 program */
  token2022Program: Address<TAccountToken2022Program>;
  /** The associated token program */
  ataProgram?: Address<TAccountAtaProgram>;
  /** DePHY ID program id */
  dephyIdProgram: Address<TAccountDephyIdProgram>;
  /** PDA as product vendor (seeds: ['VENDOR']) */
  vendor: Address<TAccountVendor>;
  /** PDA of the product mint account (program: dephy_id, seeds: ['DePHY_ID-PRODUCT', vendor, PRODUCT_NAME]) */
  productMint: Address<TAccountProductMint>;
  /** The device's owner */
  owner: Address<TAccountOwner>;
  /** PDA of the virtual device (seeds: ['DEVICE', owner]) */
  device: Address<TAccountDevice>;
  /** The associated token account of the product */
  productAtoken: Address<TAccountProductAtoken>;
  /** The mint account of the device */
  deviceMint: Address<TAccountDeviceMint>;
  /** The associated token account for the device */
  deviceAtoken: Address<TAccountDeviceAtoken>;
  challenge: CreateDeviceInstructionDataArgs['challenge'];
};

export function getCreateDeviceInstruction<
  TAccountProgramPda extends string,
  TAccountPayer extends string,
  TAccountSystemProgram extends string,
  TAccountToken2022Program extends string,
  TAccountAtaProgram extends string,
  TAccountDephyIdProgram extends string,
  TAccountVendor extends string,
  TAccountProductMint extends string,
  TAccountOwner extends string,
  TAccountDevice extends string,
  TAccountProductAtoken extends string,
  TAccountDeviceMint extends string,
  TAccountDeviceAtoken extends string,
>(
  input: CreateDeviceInput<
    TAccountProgramPda,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountToken2022Program,
    TAccountAtaProgram,
    TAccountDephyIdProgram,
    TAccountVendor,
    TAccountProductMint,
    TAccountOwner,
    TAccountDevice,
    TAccountProductAtoken,
    TAccountDeviceMint,
    TAccountDeviceAtoken
  >
): CreateDeviceInstruction<
  typeof PRODUCT_PROGRAM_PROGRAM_ADDRESS,
  TAccountProgramPda,
  TAccountPayer,
  TAccountSystemProgram,
  TAccountToken2022Program,
  TAccountAtaProgram,
  TAccountDephyIdProgram,
  TAccountVendor,
  TAccountProductMint,
  TAccountOwner,
  TAccountDevice,
  TAccountProductAtoken,
  TAccountDeviceMint,
  TAccountDeviceAtoken
> {
  // Program address.
  const programAddress = PRODUCT_PROGRAM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    programPda: { value: input.programPda ?? null, isWritable: true },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false,
    },
    ataProgram: { value: input.ataProgram ?? null, isWritable: false },
    dephyIdProgram: { value: input.dephyIdProgram ?? null, isWritable: false },
    vendor: { value: input.vendor ?? null, isWritable: false },
    productMint: { value: input.productMint ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false },
    device: { value: input.device ?? null, isWritable: false },
    productAtoken: { value: input.productAtoken ?? null, isWritable: true },
    deviceMint: { value: input.deviceMint ?? null, isWritable: true },
    deviceAtoken: { value: input.deviceAtoken ?? null, isWritable: true },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.ataProgram.value) {
    accounts.ataProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.programPda),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.ataProgram),
      getAccountMeta(accounts.dephyIdProgram),
      getAccountMeta(accounts.vendor),
      getAccountMeta(accounts.productMint),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.device),
      getAccountMeta(accounts.productAtoken),
      getAccountMeta(accounts.deviceMint),
      getAccountMeta(accounts.deviceAtoken),
    ],
    programAddress,
    data: getCreateDeviceInstructionDataEncoder().encode(
      args as CreateDeviceInstructionDataArgs
    ),
  } as CreateDeviceInstruction<
    typeof PRODUCT_PROGRAM_PROGRAM_ADDRESS,
    TAccountProgramPda,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountToken2022Program,
    TAccountAtaProgram,
    TAccountDephyIdProgram,
    TAccountVendor,
    TAccountProductMint,
    TAccountOwner,
    TAccountDevice,
    TAccountProductAtoken,
    TAccountDeviceMint,
    TAccountDeviceAtoken
  >;

  return instruction;
}

export type ParsedCreateDeviceInstruction<
  TProgram extends string = typeof PRODUCT_PROGRAM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** The program derived address of the program account to create (seeds: ['Program']) */
    programPda: TAccountMetas[0];
    /** The account paying for the storage fees */
    payer: TAccountMetas[1];
    /** The system program */
    systemProgram: TAccountMetas[2];
    /** The SPL Token 2022 program */
    token2022Program: TAccountMetas[3];
    /** The associated token program */
    ataProgram: TAccountMetas[4];
    /** DePHY ID program id */
    dephyIdProgram: TAccountMetas[5];
    /** PDA as product vendor (seeds: ['VENDOR']) */
    vendor: TAccountMetas[6];
    /** PDA of the product mint account (program: dephy_id, seeds: ['DePHY_ID-PRODUCT', vendor, PRODUCT_NAME]) */
    productMint: TAccountMetas[7];
    /** The device's owner */
    owner: TAccountMetas[8];
    /** PDA of the virtual device (seeds: ['DEVICE', owner]) */
    device: TAccountMetas[9];
    /** The associated token account of the product */
    productAtoken: TAccountMetas[10];
    /** The mint account of the device */
    deviceMint: TAccountMetas[11];
    /** The associated token account for the device */
    deviceAtoken: TAccountMetas[12];
  };
  data: CreateDeviceInstructionData;
};

export function parseCreateDeviceInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedCreateDeviceInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 13) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      programPda: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount(),
      token2022Program: getNextAccount(),
      ataProgram: getNextAccount(),
      dephyIdProgram: getNextAccount(),
      vendor: getNextAccount(),
      productMint: getNextAccount(),
      owner: getNextAccount(),
      device: getNextAccount(),
      productAtoken: getNextAccount(),
      deviceMint: getNextAccount(),
      deviceAtoken: getNextAccount(),
    },
    data: getCreateDeviceInstructionDataDecoder().decode(instruction.data),
  };
}
