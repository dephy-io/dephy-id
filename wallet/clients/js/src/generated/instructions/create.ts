/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/kinobi-so/kinobi
 */

import {
  findDeviceMintPda,
  findProductMintPda,
} from '@dephy-io/dephy-id-program-client';
import {
  combineCodec,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type ProgramDerivedAddress,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from '@solana/web3.js';
import { findVaultPda, findWalletPda } from '../pdas';
import { DEPHY_ID_WALLET_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  expectProgramDerivedAddress,
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export type CreateInstruction<
  TProgram extends string = typeof DEPHY_ID_WALLET_PROGRAM_ADDRESS,
  TAccountWallet extends string | IAccountMeta<string> = string,
  TAccountAuthority extends string | IAccountMeta<string> = string,
  TAccountVault extends string | IAccountMeta<string> = string,
  TAccountVendor extends string | IAccountMeta<string> = string,
  TAccountProductMint extends string | IAccountMeta<string> = string,
  TAccountProductAssociatedToken extends string | IAccountMeta<string> = string,
  TAccountDevice extends string | IAccountMeta<string> = string,
  TAccountDeviceMint extends string | IAccountMeta<string> = string,
  TAccountDeviceAssociatedToken extends string | IAccountMeta<string> = string,
  TAccountPayer extends string | IAccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TAccountToken2022Program extends
    | string
    | IAccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',
  TAccountAtaProgram extends
    | string
    | IAccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountWallet extends string
        ? WritableAccount<TAccountWallet>
        : TAccountWallet,
      TAccountAuthority extends string
        ? ReadonlySignerAccount<TAccountAuthority> &
            IAccountSignerMeta<TAccountAuthority>
        : TAccountAuthority,
      TAccountVault extends string
        ? ReadonlyAccount<TAccountVault>
        : TAccountVault,
      TAccountVendor extends string
        ? ReadonlyAccount<TAccountVendor>
        : TAccountVendor,
      TAccountProductMint extends string
        ? ReadonlyAccount<TAccountProductMint>
        : TAccountProductMint,
      TAccountProductAssociatedToken extends string
        ? ReadonlyAccount<TAccountProductAssociatedToken>
        : TAccountProductAssociatedToken,
      TAccountDevice extends string
        ? ReadonlyAccount<TAccountDevice>
        : TAccountDevice,
      TAccountDeviceMint extends string
        ? ReadonlyAccount<TAccountDeviceMint>
        : TAccountDeviceMint,
      TAccountDeviceAssociatedToken extends string
        ? ReadonlyAccount<TAccountDeviceAssociatedToken>
        : TAccountDeviceAssociatedToken,
      TAccountPayer extends string
        ? WritableSignerAccount<TAccountPayer> &
            IAccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountToken2022Program extends string
        ? ReadonlyAccount<TAccountToken2022Program>
        : TAccountToken2022Program,
      TAccountAtaProgram extends string
        ? ReadonlyAccount<TAccountAtaProgram>
        : TAccountAtaProgram,
      ...TRemainingAccounts,
    ]
  >;

export type CreateInstructionData = { discriminator: number; bump: number };

export type CreateInstructionDataArgs = { bump: number };

export function getCreateInstructionDataEncoder(): Encoder<CreateInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', getU8Encoder()],
      ['bump', getU8Encoder()],
    ]),
    (value) => ({ ...value, discriminator: 0 })
  );
}

export function getCreateInstructionDataDecoder(): Decoder<CreateInstructionData> {
  return getStructDecoder([
    ['discriminator', getU8Decoder()],
    ['bump', getU8Decoder()],
  ]);
}

export function getCreateInstructionDataCodec(): Codec<
  CreateInstructionDataArgs,
  CreateInstructionData
> {
  return combineCodec(
    getCreateInstructionDataEncoder(),
    getCreateInstructionDataDecoder()
  );
}

export type CreateInstructionExtraArgs = { productName: string };

export type CreateAsyncInput<
  TAccountWallet extends string = string,
  TAccountAuthority extends string = string,
  TAccountVault extends string = string,
  TAccountVendor extends string = string,
  TAccountProductMint extends string = string,
  TAccountProductAssociatedToken extends string = string,
  TAccountDevice extends string = string,
  TAccountDeviceMint extends string = string,
  TAccountDeviceAssociatedToken extends string = string,
  TAccountPayer extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountToken2022Program extends string = string,
  TAccountAtaProgram extends string = string,
> = {
  /** The program derived address of the wallet account to create (seeds: ['WALLET', authority]) */
  wallet?: ProgramDerivedAddress<TAccountWallet>;
  /** The authority of the wallet */
  authority: TransactionSigner<TAccountAuthority>;
  /** The wallet vault (seeds: ['VAULT', wallet]) */
  vault?: Address<TAccountVault>;
  /** The vendor */
  vendor: Address<TAccountVendor>;
  /** The mint account for the product */
  productMint?: Address<TAccountProductMint>;
  /** The associated token account for the product */
  productAssociatedToken: Address<TAccountProductAssociatedToken>;
  /** The device */
  device: Address<TAccountDevice>;
  /** The mint account for the device */
  deviceMint?: Address<TAccountDeviceMint>;
  /** DID associated token owned by authority */
  deviceAssociatedToken: Address<TAccountDeviceAssociatedToken>;
  /** The account paying for the storage fees */
  payer?: TransactionSigner<TAccountPayer>;
  /** The system program */
  systemProgram?: Address<TAccountSystemProgram>;
  /** The SPL Token 2022 program */
  token2022Program?: Address<TAccountToken2022Program>;
  /** The associated token program */
  ataProgram?: Address<TAccountAtaProgram>;
  bump?: CreateInstructionDataArgs['bump'];
  productName: CreateInstructionExtraArgs['productName'];
};

export async function getCreateInstructionAsync<
  TAccountWallet extends string,
  TAccountAuthority extends string,
  TAccountVault extends string,
  TAccountVendor extends string,
  TAccountProductMint extends string,
  TAccountProductAssociatedToken extends string,
  TAccountDevice extends string,
  TAccountDeviceMint extends string,
  TAccountDeviceAssociatedToken extends string,
  TAccountPayer extends string,
  TAccountSystemProgram extends string,
  TAccountToken2022Program extends string,
  TAccountAtaProgram extends string,
>(
  input: CreateAsyncInput<
    TAccountWallet,
    TAccountAuthority,
    TAccountVault,
    TAccountVendor,
    TAccountProductMint,
    TAccountProductAssociatedToken,
    TAccountDevice,
    TAccountDeviceMint,
    TAccountDeviceAssociatedToken,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountToken2022Program,
    TAccountAtaProgram
  >
): Promise<
  CreateInstruction<
    typeof DEPHY_ID_WALLET_PROGRAM_ADDRESS,
    TAccountWallet,
    TAccountAuthority,
    TAccountVault,
    TAccountVendor,
    TAccountProductMint,
    TAccountProductAssociatedToken,
    TAccountDevice,
    TAccountDeviceMint,
    TAccountDeviceAssociatedToken,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountToken2022Program,
    TAccountAtaProgram
  >
> {
  // Program address.
  const programAddress = DEPHY_ID_WALLET_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    wallet: { value: input.wallet ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    vault: { value: input.vault ?? null, isWritable: false },
    vendor: { value: input.vendor ?? null, isWritable: false },
    productMint: { value: input.productMint ?? null, isWritable: false },
    productAssociatedToken: {
      value: input.productAssociatedToken ?? null,
      isWritable: false,
    },
    device: { value: input.device ?? null, isWritable: false },
    deviceMint: { value: input.deviceMint ?? null, isWritable: false },
    deviceAssociatedToken: {
      value: input.deviceAssociatedToken ?? null,
      isWritable: false,
    },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false,
    },
    ataProgram: { value: input.ataProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.wallet.value) {
    accounts.wallet.value = await findWalletPda({
      device: expectAddress(accounts.device.value),
      authority: expectAddress(accounts.authority.value),
    });
  }
  if (!accounts.vault.value) {
    accounts.vault.value = await findVaultPda({
      wallet: expectAddress(accounts.wallet.value),
    });
  }
  if (!accounts.productMint.value) {
    accounts.productMint.value = await findProductMintPda({
      vendorPubkey: expectAddress(accounts.vendor.value),
      productName: expectSome(args.productName),
    });
  }
  if (!accounts.deviceMint.value) {
    accounts.deviceMint.value = await findDeviceMintPda({
      productMintPubkey: expectAddress(accounts.productMint.value),
      devicePubkey: expectAddress(accounts.device.value),
    });
  }
  if (!accounts.payer.value) {
    accounts.payer.value = expectSome(accounts.authority.value);
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.token2022Program.value) {
    accounts.token2022Program.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;
  }
  if (!accounts.ataProgram.value) {
    accounts.ataProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!args.bump) {
    args.bump = expectProgramDerivedAddress(accounts.wallet.value)[1];
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.wallet),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.vendor),
      getAccountMeta(accounts.productMint),
      getAccountMeta(accounts.productAssociatedToken),
      getAccountMeta(accounts.device),
      getAccountMeta(accounts.deviceMint),
      getAccountMeta(accounts.deviceAssociatedToken),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.ataProgram),
    ],
    programAddress,
    data: getCreateInstructionDataEncoder().encode(
      args as CreateInstructionDataArgs
    ),
  } as CreateInstruction<
    typeof DEPHY_ID_WALLET_PROGRAM_ADDRESS,
    TAccountWallet,
    TAccountAuthority,
    TAccountVault,
    TAccountVendor,
    TAccountProductMint,
    TAccountProductAssociatedToken,
    TAccountDevice,
    TAccountDeviceMint,
    TAccountDeviceAssociatedToken,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountToken2022Program,
    TAccountAtaProgram
  >;

  return instruction;
}

export type CreateInput<
  TAccountWallet extends string = string,
  TAccountAuthority extends string = string,
  TAccountVault extends string = string,
  TAccountVendor extends string = string,
  TAccountProductMint extends string = string,
  TAccountProductAssociatedToken extends string = string,
  TAccountDevice extends string = string,
  TAccountDeviceMint extends string = string,
  TAccountDeviceAssociatedToken extends string = string,
  TAccountPayer extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountToken2022Program extends string = string,
  TAccountAtaProgram extends string = string,
> = {
  /** The program derived address of the wallet account to create (seeds: ['WALLET', authority]) */
  wallet: ProgramDerivedAddress<TAccountWallet>;
  /** The authority of the wallet */
  authority: TransactionSigner<TAccountAuthority>;
  /** The wallet vault (seeds: ['VAULT', wallet]) */
  vault: Address<TAccountVault>;
  /** The vendor */
  vendor: Address<TAccountVendor>;
  /** The mint account for the product */
  productMint: Address<TAccountProductMint>;
  /** The associated token account for the product */
  productAssociatedToken: Address<TAccountProductAssociatedToken>;
  /** The device */
  device: Address<TAccountDevice>;
  /** The mint account for the device */
  deviceMint: Address<TAccountDeviceMint>;
  /** DID associated token owned by authority */
  deviceAssociatedToken: Address<TAccountDeviceAssociatedToken>;
  /** The account paying for the storage fees */
  payer?: TransactionSigner<TAccountPayer>;
  /** The system program */
  systemProgram?: Address<TAccountSystemProgram>;
  /** The SPL Token 2022 program */
  token2022Program?: Address<TAccountToken2022Program>;
  /** The associated token program */
  ataProgram?: Address<TAccountAtaProgram>;
  bump?: CreateInstructionDataArgs['bump'];
  productName: CreateInstructionExtraArgs['productName'];
};

export function getCreateInstruction<
  TAccountWallet extends string,
  TAccountAuthority extends string,
  TAccountVault extends string,
  TAccountVendor extends string,
  TAccountProductMint extends string,
  TAccountProductAssociatedToken extends string,
  TAccountDevice extends string,
  TAccountDeviceMint extends string,
  TAccountDeviceAssociatedToken extends string,
  TAccountPayer extends string,
  TAccountSystemProgram extends string,
  TAccountToken2022Program extends string,
  TAccountAtaProgram extends string,
>(
  input: CreateInput<
    TAccountWallet,
    TAccountAuthority,
    TAccountVault,
    TAccountVendor,
    TAccountProductMint,
    TAccountProductAssociatedToken,
    TAccountDevice,
    TAccountDeviceMint,
    TAccountDeviceAssociatedToken,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountToken2022Program,
    TAccountAtaProgram
  >
): CreateInstruction<
  typeof DEPHY_ID_WALLET_PROGRAM_ADDRESS,
  TAccountWallet,
  TAccountAuthority,
  TAccountVault,
  TAccountVendor,
  TAccountProductMint,
  TAccountProductAssociatedToken,
  TAccountDevice,
  TAccountDeviceMint,
  TAccountDeviceAssociatedToken,
  TAccountPayer,
  TAccountSystemProgram,
  TAccountToken2022Program,
  TAccountAtaProgram
> {
  // Program address.
  const programAddress = DEPHY_ID_WALLET_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    wallet: { value: input.wallet ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    vault: { value: input.vault ?? null, isWritable: false },
    vendor: { value: input.vendor ?? null, isWritable: false },
    productMint: { value: input.productMint ?? null, isWritable: false },
    productAssociatedToken: {
      value: input.productAssociatedToken ?? null,
      isWritable: false,
    },
    device: { value: input.device ?? null, isWritable: false },
    deviceMint: { value: input.deviceMint ?? null, isWritable: false },
    deviceAssociatedToken: {
      value: input.deviceAssociatedToken ?? null,
      isWritable: false,
    },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false,
    },
    ataProgram: { value: input.ataProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.payer.value) {
    accounts.payer.value = expectSome(accounts.authority.value);
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.token2022Program.value) {
    accounts.token2022Program.value =
      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;
  }
  if (!accounts.ataProgram.value) {
    accounts.ataProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }
  if (!args.bump) {
    args.bump = expectProgramDerivedAddress(accounts.wallet.value)[1];
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.wallet),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.vendor),
      getAccountMeta(accounts.productMint),
      getAccountMeta(accounts.productAssociatedToken),
      getAccountMeta(accounts.device),
      getAccountMeta(accounts.deviceMint),
      getAccountMeta(accounts.deviceAssociatedToken),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.ataProgram),
    ],
    programAddress,
    data: getCreateInstructionDataEncoder().encode(
      args as CreateInstructionDataArgs
    ),
  } as CreateInstruction<
    typeof DEPHY_ID_WALLET_PROGRAM_ADDRESS,
    TAccountWallet,
    TAccountAuthority,
    TAccountVault,
    TAccountVendor,
    TAccountProductMint,
    TAccountProductAssociatedToken,
    TAccountDevice,
    TAccountDeviceMint,
    TAccountDeviceAssociatedToken,
    TAccountPayer,
    TAccountSystemProgram,
    TAccountToken2022Program,
    TAccountAtaProgram
  >;

  return instruction;
}

export type ParsedCreateInstruction<
  TProgram extends string = typeof DEPHY_ID_WALLET_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** The program derived address of the wallet account to create (seeds: ['WALLET', authority]) */
    wallet: TAccountMetas[0];
    /** The authority of the wallet */
    authority: TAccountMetas[1];
    /** The wallet vault (seeds: ['VAULT', wallet]) */
    vault: TAccountMetas[2];
    /** The vendor */
    vendor: TAccountMetas[3];
    /** The mint account for the product */
    productMint: TAccountMetas[4];
    /** The associated token account for the product */
    productAssociatedToken: TAccountMetas[5];
    /** The device */
    device: TAccountMetas[6];
    /** The mint account for the device */
    deviceMint: TAccountMetas[7];
    /** DID associated token owned by authority */
    deviceAssociatedToken: TAccountMetas[8];
    /** The account paying for the storage fees */
    payer: TAccountMetas[9];
    /** The system program */
    systemProgram: TAccountMetas[10];
    /** The SPL Token 2022 program */
    token2022Program: TAccountMetas[11];
    /** The associated token program */
    ataProgram: TAccountMetas[12];
  };
  data: CreateInstructionData;
};

export function parseCreateInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedCreateInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 13) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      wallet: getNextAccount(),
      authority: getNextAccount(),
      vault: getNextAccount(),
      vendor: getNextAccount(),
      productMint: getNextAccount(),
      productAssociatedToken: getNextAccount(),
      device: getNextAccount(),
      deviceMint: getNextAccount(),
      deviceAssociatedToken: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount(),
      token2022Program: getNextAccount(),
      ataProgram: getNextAccount(),
    },
    data: getCreateInstructionDataDecoder().decode(instruction.data),
  };
}
