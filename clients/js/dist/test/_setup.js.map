{"version":3,"sources":["../../test/_setup.ts"],"names":[],"mappings":"AAAA;AAAA,EAUE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAOA,MAAM,4BAA4B,MAAc;AACrD,QAAM,MAAM,gBAAgB,uBAAuB;AACnD,QAAM,mBAAmB,6BAA6B,qBAAqB;AAC3E,SAAO,EAAE,KAAK,iBAAiB;AACjC;AAEO,MAAM,+BAA+B,OAC1C,QACA,mBAA2B,gBACxB;AACH,QAAM,SAAS,MAAM,sBAAsB;AAC3C,QAAM,eAAe,MAAM,EAAE;AAAA,IAC3B,kBAAkB,OAAO;AAAA,IACzB,UAAU,SAAS,gBAAgB;AAAA,IACnC,YAAY;AAAA,EACd,CAAC;AACD,SAAO;AACT;AAEO,MAAM,2BAA2B,OACtC,QACA,aACG;AACH,QAAM,EAAE,OAAO,gBAAgB,IAAI,MAAM,OAAO,IAC7C,mBAAmB,EACnB,KAAK;AACR,SAAO;AAAA,IACL,yBAAyB,EAAE,SAAS,EAAE,CAAC;AAAA,IACvC,CAAC,OAAO,oCAAoC,UAAU,EAAE;AAAA,IACxD,CAAC,OAAO,4CAA4C,iBAAiB,EAAE;AAAA,EACzE;AACF;AAEO,MAAM,yBAAyB,OACpC,QACA,oBAEA,aAAyB,gBACtB;AACH,QAAM,oBACJ,MAAM,kCAAkC,kBAAkB;AAC5D,QAAM,YAAY,4BAA4B,iBAAiB;AAC/D,QAAM,iCAAiC,MAAM,EAAE,mBAAmB;AAAA,IAChE;AAAA,EACF,CAAC;AACD,SAAO;AACT;AAEO,MAAM,aAAa,OAAO,QAAgB,aAC9C,MAAM,OAAO,IAAI,WAAW,SAAS,EAAE,YAAY,YAAY,CAAC,EAAE,KAAK,GACrE","sourcesContent":["import {\n  Address,\n  Commitment,\n  CompilableTransactionMessage,\n  TransactionMessageWithBlockhashLifetime,\n  Rpc,\n  RpcSubscriptions,\n  SolanaRpcApi,\n  SolanaRpcSubscriptionsApi,\n  TransactionSigner,\n  airdropFactory,\n  createSolanaRpc,\n  createSolanaRpcSubscriptions,\n  createTransactionMessage,\n  generateKeyPairSigner,\n  getSignatureFromTransaction,\n  lamports,\n  pipe,\n  sendAndConfirmTransactionFactory,\n  setTransactionMessageFeePayerSigner,\n  setTransactionMessageLifetimeUsingBlockhash,\n  signTransactionMessageWithSigners,\n} from '@solana/web3.js';\n\ntype Client = {\n  rpc: Rpc<SolanaRpcApi>;\n  rpcSubscriptions: RpcSubscriptions<SolanaRpcSubscriptionsApi>;\n};\n\nexport const createDefaultSolanaClient = (): Client => {\n  const rpc = createSolanaRpc('http://127.0.0.1:8899');\n  const rpcSubscriptions = createSolanaRpcSubscriptions('ws://127.0.0.1:8900');\n  return { rpc, rpcSubscriptions };\n};\n\nexport const generateKeyPairSignerWithSol = async (\n  client: Client,\n  putativeLamports: bigint = 1_000_000_000n\n) => {\n  const signer = await generateKeyPairSigner();\n  await airdropFactory(client)({\n    recipientAddress: signer.address,\n    lamports: lamports(putativeLamports),\n    commitment: 'confirmed',\n  });\n  return signer;\n};\n\nexport const createDefaultTransaction = async (\n  client: Client,\n  feePayer: TransactionSigner\n) => {\n  const { value: latestBlockhash } = await client.rpc\n    .getLatestBlockhash()\n    .send();\n  return pipe(\n    createTransactionMessage({ version: 0 }),\n    (tx) => setTransactionMessageFeePayerSigner(feePayer, tx),\n    (tx) => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx)\n  );\n};\n\nexport const signAndSendTransaction = async (\n  client: Client,\n  transactionMessage: CompilableTransactionMessage &\n    TransactionMessageWithBlockhashLifetime,\n  commitment: Commitment = 'confirmed'\n) => {\n  const signedTransaction =\n    await signTransactionMessageWithSigners(transactionMessage);\n  const signature = getSignatureFromTransaction(signedTransaction);\n  await sendAndConfirmTransactionFactory(client)(signedTransaction, {\n    commitment,\n  });\n  return signature;\n};\n\nexport const getBalance = async (client: Client, address: Address) =>\n  (await client.rpc.getBalance(address, { commitment: 'confirmed' }).send())\n    .value;\n"]}