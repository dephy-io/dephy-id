{"version":3,"sources":["../../env-shim.ts","../../src/generated/accounts/programDataAccount.ts","../../src/generated/pdas/programDataAccount.ts","../../src/generated/types/deviceSigningAlgorithm.ts","../../src/generated/types/key.ts","../../src/generated/types/programData.ts","../../src/generated/errors/dephyId.ts","../../src/generated/instructions/activateDevice.ts","../../src/generated/programs/dephyId.ts","../../src/generated/shared/index.ts","../../src/generated/instructions/createDevice.ts","../../src/generated/instructions/createProduct.ts","../../src/generated/instructions/initialize.ts"],"names":["combineCodec","getStructDecoder","getStructEncoder","DeviceSigningAlgorithm","getEnumDecoder","getEnumEncoder","Key","getU8Decoder","getU8Encoder","transformEncoder","DephyIdAccount","DephyIdInstruction","getUtf8Encoder","addDecoderSizePrefix","addEncoderSizePrefix","getArrayDecoder","getArrayEncoder","getTupleDecoder","getTupleEncoder","getU32Decoder","getU32Encoder","getUtf8Decoder"],"mappings":"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","sourcesContent":["// Clever obfuscation to prevent the build system from inlining the value of `NODE_ENV`\nexport const __DEV__ = /* @__PURE__ */ (() =>\n  (process as any)['en' + 'v'].NODE_ENV === 'development')();\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  Account,\n  Address,\n  Codec,\n  Decoder,\n  EncodedAccount,\n  Encoder,\n  FetchAccountConfig,\n  FetchAccountsConfig,\n  MaybeAccount,\n  MaybeEncodedAccount,\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n} from '@solana/web3.js';\nimport { findProgramDataAccountPda } from '../pdas';\nimport {\n  Key,\n  ProgramData,\n  ProgramDataArgs,\n  getKeyDecoder,\n  getKeyEncoder,\n  getProgramDataDecoder,\n  getProgramDataEncoder,\n} from '../types';\n\nexport type ProgramDataAccount = {\n  key: Key;\n  authority: Address;\n  data: ProgramData;\n};\n\nexport type ProgramDataAccountArgs = {\n  authority: Address;\n  data: ProgramDataArgs;\n};\n\nexport function getProgramDataAccountEncoder(): Encoder<ProgramDataAccountArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['key', getKeyEncoder()],\n      ['authority', getAddressEncoder()],\n      ['data', getProgramDataEncoder()],\n    ]),\n    (value) => ({ ...value, key: Key.ProgramDataAccount })\n  );\n}\n\nexport function getProgramDataAccountDecoder(): Decoder<ProgramDataAccount> {\n  return getStructDecoder([\n    ['key', getKeyDecoder()],\n    ['authority', getAddressDecoder()],\n    ['data', getProgramDataDecoder()],\n  ]);\n}\n\nexport function getProgramDataAccountCodec(): Codec<\n  ProgramDataAccountArgs,\n  ProgramDataAccount\n> {\n  return combineCodec(\n    getProgramDataAccountEncoder(),\n    getProgramDataAccountDecoder()\n  );\n}\n\nexport function decodeProgramDataAccount<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<ProgramDataAccount, TAddress>;\nexport function decodeProgramDataAccount<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<ProgramDataAccount, TAddress>;\nexport function decodeProgramDataAccount<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n):\n  | Account<ProgramDataAccount, TAddress>\n  | MaybeAccount<ProgramDataAccount, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getProgramDataAccountDecoder()\n  );\n}\n\nexport async function fetchProgramDataAccount<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<ProgramDataAccount, TAddress>> {\n  const maybeAccount = await fetchMaybeProgramDataAccount(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeProgramDataAccount<\n  TAddress extends string = string,\n>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<ProgramDataAccount, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeProgramDataAccount(maybeAccount);\n}\n\nexport async function fetchAllProgramDataAccount(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<ProgramDataAccount>[]> {\n  const maybeAccounts = await fetchAllMaybeProgramDataAccount(\n    rpc,\n    addresses,\n    config\n  );\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeProgramDataAccount(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<ProgramDataAccount>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) =>\n    decodeProgramDataAccount(maybeAccount)\n  );\n}\n\nexport function getProgramDataAccountSize(): number {\n  return 34;\n}\n\nexport async function fetchProgramDataAccountFromSeeds(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  config: FetchAccountConfig & { programAddress?: Address } = {}\n): Promise<Account<ProgramDataAccount>> {\n  const maybeAccount = await fetchMaybeProgramDataAccountFromSeeds(rpc, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeProgramDataAccountFromSeeds(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  config: FetchAccountConfig & { programAddress?: Address } = {}\n): Promise<MaybeAccount<ProgramDataAccount>> {\n  const { programAddress, ...fetchConfig } = config;\n  const [address] = await findProgramDataAccountPda({ programAddress });\n  return await fetchMaybeProgramDataAccount(rpc, address, fetchConfig);\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  Address,\n  ProgramDerivedAddress,\n  getProgramDerivedAddress,\n  getUtf8Encoder,\n} from '@solana/web3.js';\n\nexport async function findProgramDataAccountPda(\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'hdMghjD73uASxgJXi6e1mGPsXqnADMsrqB1bveqABP1' as Address<'hdMghjD73uASxgJXi6e1mGPsXqnADMsrqB1bveqABP1'>,\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [getUtf8Encoder().encode('DePHY_ID')],\n  });\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n} from '@solana/web3.js';\n\nexport enum DeviceSigningAlgorithm {\n  Ed25519,\n  Secp256k1,\n}\n\nexport type DeviceSigningAlgorithmArgs = DeviceSigningAlgorithm;\n\nexport function getDeviceSigningAlgorithmEncoder(): Encoder<DeviceSigningAlgorithmArgs> {\n  return getEnumEncoder(DeviceSigningAlgorithm);\n}\n\nexport function getDeviceSigningAlgorithmDecoder(): Decoder<DeviceSigningAlgorithm> {\n  return getEnumDecoder(DeviceSigningAlgorithm);\n}\n\nexport function getDeviceSigningAlgorithmCodec(): Codec<\n  DeviceSigningAlgorithmArgs,\n  DeviceSigningAlgorithm\n> {\n  return combineCodec(\n    getDeviceSigningAlgorithmEncoder(),\n    getDeviceSigningAlgorithmDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n} from '@solana/web3.js';\n\nexport enum Key {\n  Uninitialized,\n  ProgramDataAccount,\n}\n\nexport type KeyArgs = Key;\n\nexport function getKeyEncoder(): Encoder<KeyArgs> {\n  return getEnumEncoder(Key);\n}\n\nexport function getKeyDecoder(): Decoder<Key> {\n  return getEnumDecoder(Key);\n}\n\nexport function getKeyCodec(): Codec<KeyArgs, Key> {\n  return combineCodec(getKeyEncoder(), getKeyDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  Codec,\n  Decoder,\n  Encoder,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n} from '@solana/web3.js';\n\nexport type ProgramData = { bump: number };\n\nexport type ProgramDataArgs = ProgramData;\n\nexport function getProgramDataEncoder(): Encoder<ProgramDataArgs> {\n  return getStructEncoder([['bump', getU8Encoder()]]);\n}\n\nexport function getProgramDataDecoder(): Decoder<ProgramData> {\n  return getStructDecoder([['bump', getU8Decoder()]]);\n}\n\nexport function getProgramDataCodec(): Codec<ProgramDataArgs, ProgramData> {\n  return combineCodec(getProgramDataEncoder(), getProgramDataDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\n/** DeserializationError: Error deserializing an account */\nexport const DEPHY_ID_ERROR__DESERIALIZATION_ERROR = 0x0; // 0\n/** SerializationError: Error serializing an account */\nexport const DEPHY_ID_ERROR__SERIALIZATION_ERROR = 0x1; // 1\n/** InvalidProgramOwner: Invalid program owner. This likely mean the provided account does not exist */\nexport const DEPHY_ID_ERROR__INVALID_PROGRAM_OWNER = 0x2; // 2\n/** InvalidPda: Invalid PDA derivation */\nexport const DEPHY_ID_ERROR__INVALID_PDA = 0x3; // 3\n/** ExpectedEmptyAccount: Expected empty account */\nexport const DEPHY_ID_ERROR__EXPECTED_EMPTY_ACCOUNT = 0x4; // 4\n/** ExpectedNonEmptyAccount: Expected non empty account */\nexport const DEPHY_ID_ERROR__EXPECTED_NON_EMPTY_ACCOUNT = 0x5; // 5\n/** ExpectedSignerAccount: Expected signer account */\nexport const DEPHY_ID_ERROR__EXPECTED_SIGNER_ACCOUNT = 0x6; // 6\n/** ExpectedWritableAccount: Expected writable account */\nexport const DEPHY_ID_ERROR__EXPECTED_WRITABLE_ACCOUNT = 0x7; // 7\n/** AccountMismatch: Account mismatch */\nexport const DEPHY_ID_ERROR__ACCOUNT_MISMATCH = 0x8; // 8\n/** InvalidAccountKey: Invalid account key */\nexport const DEPHY_ID_ERROR__INVALID_ACCOUNT_KEY = 0x9; // 9\n/** NumericalOverflow: Numerical overflow */\nexport const DEPHY_ID_ERROR__NUMERICAL_OVERFLOW = 0xa; // 10\n/** MissingInstruction: Missing instruction */\nexport const DEPHY_ID_ERROR__MISSING_INSTRUCTION = 0xb; // 11\n\nexport type DephyIdError =\n  | typeof DEPHY_ID_ERROR__ACCOUNT_MISMATCH\n  | typeof DEPHY_ID_ERROR__DESERIALIZATION_ERROR\n  | typeof DEPHY_ID_ERROR__EXPECTED_EMPTY_ACCOUNT\n  | typeof DEPHY_ID_ERROR__EXPECTED_NON_EMPTY_ACCOUNT\n  | typeof DEPHY_ID_ERROR__EXPECTED_SIGNER_ACCOUNT\n  | typeof DEPHY_ID_ERROR__EXPECTED_WRITABLE_ACCOUNT\n  | typeof DEPHY_ID_ERROR__INVALID_ACCOUNT_KEY\n  | typeof DEPHY_ID_ERROR__INVALID_PDA\n  | typeof DEPHY_ID_ERROR__INVALID_PROGRAM_OWNER\n  | typeof DEPHY_ID_ERROR__MISSING_INSTRUCTION\n  | typeof DEPHY_ID_ERROR__NUMERICAL_OVERFLOW\n  | typeof DEPHY_ID_ERROR__SERIALIZATION_ERROR;\n\nlet dephyIdErrorMessages: Record<DephyIdError, string> | undefined;\nif (__DEV__) {\n  dephyIdErrorMessages = {\n    [DEPHY_ID_ERROR__ACCOUNT_MISMATCH]: `Account mismatch`,\n    [DEPHY_ID_ERROR__DESERIALIZATION_ERROR]: `Error deserializing an account`,\n    [DEPHY_ID_ERROR__EXPECTED_EMPTY_ACCOUNT]: `Expected empty account`,\n    [DEPHY_ID_ERROR__EXPECTED_NON_EMPTY_ACCOUNT]: `Expected non empty account`,\n    [DEPHY_ID_ERROR__EXPECTED_SIGNER_ACCOUNT]: `Expected signer account`,\n    [DEPHY_ID_ERROR__EXPECTED_WRITABLE_ACCOUNT]: `Expected writable account`,\n    [DEPHY_ID_ERROR__INVALID_ACCOUNT_KEY]: `Invalid account key`,\n    [DEPHY_ID_ERROR__INVALID_PDA]: `Invalid PDA derivation`,\n    [DEPHY_ID_ERROR__INVALID_PROGRAM_OWNER]: `Invalid program owner. This likely mean the provided account does not exist`,\n    [DEPHY_ID_ERROR__MISSING_INSTRUCTION]: `Missing instruction`,\n    [DEPHY_ID_ERROR__NUMERICAL_OVERFLOW]: `Numerical overflow`,\n    [DEPHY_ID_ERROR__SERIALIZATION_ERROR]: `Error serializing an account`,\n  };\n}\n\nexport function getDephyIdErrorMessage(code: DephyIdError): string {\n  if (__DEV__) {\n    return (dephyIdErrorMessages as Record<DephyIdError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles. Compile with `__DEV__` set to true to see more information.';\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  Address,\n  Codec,\n  Decoder,\n  Encoder,\n  IAccountMeta,\n  IAccountSignerMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n  TransactionSigner,\n  WritableAccount,\n  WritableSignerAccount,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n} from '@solana/web3.js';\nimport { DEPHY_ID_PROGRAM_ADDRESS } from '../programs';\nimport { ResolvedAccount, getAccountMetaFactory } from '../shared';\nimport {\n  DeviceSigningAlgorithm,\n  DeviceSigningAlgorithmArgs,\n  getDeviceSigningAlgorithmDecoder,\n  getDeviceSigningAlgorithmEncoder,\n} from '../types';\n\nexport type ActivateDeviceInstruction<\n  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountToken2022Program extends string | IAccountMeta<string> = string,\n  TAccountAtaProgram extends\n    | string\n    | IAccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n  TAccountInstructions extends string | IAccountMeta<string> = string,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountVendor extends string | IAccountMeta<string> = string,\n  TAccountProductMint extends string | IAccountMeta<string> = string,\n  TAccountProductAssociatedToken extends string | IAccountMeta<string> = string,\n  TAccountDevice extends string | IAccountMeta<string> = string,\n  TAccountDeviceMint extends string | IAccountMeta<string> = string,\n  TAccountDeviceAssociatedToken extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountToken2022Program extends string\n        ? ReadonlyAccount<TAccountToken2022Program>\n        : TAccountToken2022Program,\n      TAccountAtaProgram extends string\n        ? ReadonlyAccount<TAccountAtaProgram>\n        : TAccountAtaProgram,\n      TAccountInstructions extends string\n        ? ReadonlyAccount<TAccountInstructions>\n        : TAccountInstructions,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountVendor extends string\n        ? ReadonlyAccount<TAccountVendor>\n        : TAccountVendor,\n      TAccountProductMint extends string\n        ? ReadonlyAccount<TAccountProductMint>\n        : TAccountProductMint,\n      TAccountProductAssociatedToken extends string\n        ? ReadonlyAccount<TAccountProductAssociatedToken>\n        : TAccountProductAssociatedToken,\n      TAccountDevice extends string\n        ? ReadonlyAccount<TAccountDevice>\n        : TAccountDevice,\n      TAccountDeviceMint extends string\n        ? WritableAccount<TAccountDeviceMint>\n        : TAccountDeviceMint,\n      TAccountDeviceAssociatedToken extends string\n        ? WritableAccount<TAccountDeviceAssociatedToken>\n        : TAccountDeviceAssociatedToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ActivateDeviceInstructionData = {\n  discriminator: number;\n  signingAlg: DeviceSigningAlgorithm;\n};\n\nexport type ActivateDeviceInstructionDataArgs = {\n  signingAlg: DeviceSigningAlgorithmArgs;\n};\n\nexport function getActivateDeviceInstructionDataEncoder(): Encoder<ActivateDeviceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['signingAlg', getDeviceSigningAlgorithmEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: 3 })\n  );\n}\n\nexport function getActivateDeviceInstructionDataDecoder(): Decoder<ActivateDeviceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['signingAlg', getDeviceSigningAlgorithmDecoder()],\n  ]);\n}\n\nexport function getActivateDeviceInstructionDataCodec(): Codec<\n  ActivateDeviceInstructionDataArgs,\n  ActivateDeviceInstructionData\n> {\n  return combineCodec(\n    getActivateDeviceInstructionDataEncoder(),\n    getActivateDeviceInstructionDataDecoder()\n  );\n}\n\nexport type ActivateDeviceInput<\n  TAccountSystemProgram extends string = string,\n  TAccountToken2022Program extends string = string,\n  TAccountAtaProgram extends string = string,\n  TAccountInstructions extends string = string,\n  TAccountPayer extends string = string,\n  TAccountVendor extends string = string,\n  TAccountProductMint extends string = string,\n  TAccountProductAssociatedToken extends string = string,\n  TAccountDevice extends string = string,\n  TAccountDeviceMint extends string = string,\n  TAccountDeviceAssociatedToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The system program */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** The SPL Token 2022 program */\n  token2022Program: Address<TAccountToken2022Program>;\n  /** The associated token program */\n  ataProgram?: Address<TAccountAtaProgram>;\n  /** The instructions sysvar */\n  instructions: Address<TAccountInstructions>;\n  /** The account paying for the storage fees */\n  payer: TransactionSigner<TAccountPayer>;\n  /** The vendor */\n  vendor: Address<TAccountVendor>;\n  /** The mint account for the product */\n  productMint: Address<TAccountProductMint>;\n  /** The associated token account for the product */\n  productAssociatedToken: Address<TAccountProductAssociatedToken>;\n  /** The device */\n  device: Address<TAccountDevice>;\n  /** The mint account for the device */\n  deviceMint: Address<TAccountDeviceMint>;\n  /** The associated token account for the device */\n  deviceAssociatedToken: Address<TAccountDeviceAssociatedToken>;\n  /** The device's owner */\n  owner: Address<TAccountOwner>;\n  signingAlg: ActivateDeviceInstructionDataArgs['signingAlg'];\n};\n\nexport function getActivateDeviceInstruction<\n  TAccountSystemProgram extends string,\n  TAccountToken2022Program extends string,\n  TAccountAtaProgram extends string,\n  TAccountInstructions extends string,\n  TAccountPayer extends string,\n  TAccountVendor extends string,\n  TAccountProductMint extends string,\n  TAccountProductAssociatedToken extends string,\n  TAccountDevice extends string,\n  TAccountDeviceMint extends string,\n  TAccountDeviceAssociatedToken extends string,\n  TAccountOwner extends string,\n>(\n  input: ActivateDeviceInput<\n    TAccountSystemProgram,\n    TAccountToken2022Program,\n    TAccountAtaProgram,\n    TAccountInstructions,\n    TAccountPayer,\n    TAccountVendor,\n    TAccountProductMint,\n    TAccountProductAssociatedToken,\n    TAccountDevice,\n    TAccountDeviceMint,\n    TAccountDeviceAssociatedToken,\n    TAccountOwner\n  >\n): ActivateDeviceInstruction<\n  typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountSystemProgram,\n  TAccountToken2022Program,\n  TAccountAtaProgram,\n  TAccountInstructions,\n  TAccountPayer,\n  TAccountVendor,\n  TAccountProductMint,\n  TAccountProductAssociatedToken,\n  TAccountDevice,\n  TAccountDeviceMint,\n  TAccountDeviceAssociatedToken,\n  TAccountOwner\n> {\n  // Program address.\n  const programAddress = DEPHY_ID_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    token2022Program: {\n      value: input.token2022Program ?? null,\n      isWritable: false,\n    },\n    ataProgram: { value: input.ataProgram ?? null, isWritable: false },\n    instructions: { value: input.instructions ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    vendor: { value: input.vendor ?? null, isWritable: false },\n    productMint: { value: input.productMint ?? null, isWritable: false },\n    productAssociatedToken: {\n      value: input.productAssociatedToken ?? null,\n      isWritable: false,\n    },\n    device: { value: input.device ?? null, isWritable: false },\n    deviceMint: { value: input.deviceMint ?? null, isWritable: true },\n    deviceAssociatedToken: {\n      value: input.deviceAssociatedToken ?? null,\n      isWritable: true,\n    },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.ataProgram.value) {\n    accounts.ataProgram.value =\n      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.token2022Program),\n      getAccountMeta(accounts.ataProgram),\n      getAccountMeta(accounts.instructions),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.vendor),\n      getAccountMeta(accounts.productMint),\n      getAccountMeta(accounts.productAssociatedToken),\n      getAccountMeta(accounts.device),\n      getAccountMeta(accounts.deviceMint),\n      getAccountMeta(accounts.deviceAssociatedToken),\n      getAccountMeta(accounts.owner),\n    ],\n    programAddress,\n    data: getActivateDeviceInstructionDataEncoder().encode(\n      args as ActivateDeviceInstructionDataArgs\n    ),\n  } as ActivateDeviceInstruction<\n    typeof DEPHY_ID_PROGRAM_ADDRESS,\n    TAccountSystemProgram,\n    TAccountToken2022Program,\n    TAccountAtaProgram,\n    TAccountInstructions,\n    TAccountPayer,\n    TAccountVendor,\n    TAccountProductMint,\n    TAccountProductAssociatedToken,\n    TAccountDevice,\n    TAccountDeviceMint,\n    TAccountDeviceAssociatedToken,\n    TAccountOwner\n  >;\n\n  return instruction;\n}\n\nexport type ParsedActivateDeviceInstruction<\n  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The system program */\n    systemProgram: TAccountMetas[0];\n    /** The SPL Token 2022 program */\n    token2022Program: TAccountMetas[1];\n    /** The associated token program */\n    ataProgram: TAccountMetas[2];\n    /** The instructions sysvar */\n    instructions: TAccountMetas[3];\n    /** The account paying for the storage fees */\n    payer: TAccountMetas[4];\n    /** The vendor */\n    vendor: TAccountMetas[5];\n    /** The mint account for the product */\n    productMint: TAccountMetas[6];\n    /** The associated token account for the product */\n    productAssociatedToken: TAccountMetas[7];\n    /** The device */\n    device: TAccountMetas[8];\n    /** The mint account for the device */\n    deviceMint: TAccountMetas[9];\n    /** The associated token account for the device */\n    deviceAssociatedToken: TAccountMetas[10];\n    /** The device's owner */\n    owner: TAccountMetas[11];\n  };\n  data: ActivateDeviceInstructionData;\n};\n\nexport function parseActivateDeviceInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedActivateDeviceInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 12) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      systemProgram: getNextAccount(),\n      token2022Program: getNextAccount(),\n      ataProgram: getNextAccount(),\n      instructions: getNextAccount(),\n      payer: getNextAccount(),\n      vendor: getNextAccount(),\n      productMint: getNextAccount(),\n      productAssociatedToken: getNextAccount(),\n      device: getNextAccount(),\n      deviceMint: getNextAccount(),\n      deviceAssociatedToken: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getActivateDeviceInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport { Address, containsBytes, getU8Encoder } from '@solana/web3.js';\nimport {\n  ParsedActivateDeviceInstruction,\n  ParsedCreateDeviceInstruction,\n  ParsedCreateProductInstruction,\n  ParsedInitializeInstruction,\n} from '../instructions';\nimport { Key, getKeyEncoder } from '../types';\n\nexport const DEPHY_ID_PROGRAM_ADDRESS =\n  'hdMghjD73uASxgJXi6e1mGPsXqnADMsrqB1bveqABP1' as Address<'hdMghjD73uASxgJXi6e1mGPsXqnADMsrqB1bveqABP1'>;\n\nexport enum DephyIdAccount {\n  ProgramDataAccount,\n}\n\nexport function identifyDephyIdAccount(\n  account: { data: Uint8Array } | Uint8Array\n): DephyIdAccount {\n  const data = account instanceof Uint8Array ? account : account.data;\n  if (containsBytes(data, getKeyEncoder().encode(Key.ProgramDataAccount), 0)) {\n    return DephyIdAccount.ProgramDataAccount;\n  }\n  throw new Error(\n    'The provided account could not be identified as a dephyId account.'\n  );\n}\n\nexport enum DephyIdInstruction {\n  Initialize,\n  CreateProduct,\n  CreateDevice,\n  ActivateDevice,\n}\n\nexport function identifyDephyIdInstruction(\n  instruction: { data: Uint8Array } | Uint8Array\n): DephyIdInstruction {\n  const data =\n    instruction instanceof Uint8Array ? instruction : instruction.data;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return DephyIdInstruction.Initialize;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return DephyIdInstruction.CreateProduct;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return DephyIdInstruction.CreateDevice;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return DephyIdInstruction.ActivateDevice;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a dephyId instruction.'\n  );\n}\n\nexport type ParsedDephyIdInstruction<\n  TProgram extends string = 'hdMghjD73uASxgJXi6e1mGPsXqnADMsrqB1bveqABP1',\n> =\n  | ({\n      instructionType: DephyIdInstruction.Initialize;\n    } & ParsedInitializeInstruction<TProgram>)\n  | ({\n      instructionType: DephyIdInstruction.CreateProduct;\n    } & ParsedCreateProductInstruction<TProgram>)\n  | ({\n      instructionType: DephyIdInstruction.CreateDevice;\n    } & ParsedCreateDeviceInstruction<TProgram>)\n  | ({\n      instructionType: DephyIdInstruction.ActivateDevice;\n    } & ParsedActivateDeviceInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  AccountRole,\n  Address,\n  IAccountMeta,\n  IAccountSignerMeta,\n  ProgramDerivedAddress,\n  TransactionSigner,\n  isProgramDerivedAddress,\n  isTransactionSigner as web3JsIsTransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/web3.js';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    web3JsIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  Address,\n  Codec,\n  Decoder,\n  Encoder,\n  IAccountMeta,\n  IAccountSignerMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n  ReadonlySignerAccount,\n  TransactionSigner,\n  WritableAccount,\n  WritableSignerAccount,\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n} from '@solana/web3.js';\nimport { DEPHY_ID_PROGRAM_ADDRESS } from '../programs';\nimport { ResolvedAccount, getAccountMetaFactory } from '../shared';\nimport {\n  DeviceSigningAlgorithm,\n  DeviceSigningAlgorithmArgs,\n  getDeviceSigningAlgorithmDecoder,\n  getDeviceSigningAlgorithmEncoder,\n} from '../types';\n\nexport type CreateDeviceInstruction<\n  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountToken2022Program extends string | IAccountMeta<string> = string,\n  TAccountAtaProgram extends\n    | string\n    | IAccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountVendor extends string | IAccountMeta<string> = string,\n  TAccountProductMint extends string | IAccountMeta<string> = string,\n  TAccountProductAssociatedToken extends string | IAccountMeta<string> = string,\n  TAccountDevice extends string | IAccountMeta<string> = string,\n  TAccountDeviceMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountToken2022Program extends string\n        ? ReadonlyAccount<TAccountToken2022Program>\n        : TAccountToken2022Program,\n      TAccountAtaProgram extends string\n        ? ReadonlyAccount<TAccountAtaProgram>\n        : TAccountAtaProgram,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountVendor extends string\n        ? ReadonlySignerAccount<TAccountVendor> &\n            IAccountSignerMeta<TAccountVendor>\n        : TAccountVendor,\n      TAccountProductMint extends string\n        ? WritableAccount<TAccountProductMint>\n        : TAccountProductMint,\n      TAccountProductAssociatedToken extends string\n        ? WritableAccount<TAccountProductAssociatedToken>\n        : TAccountProductAssociatedToken,\n      TAccountDevice extends string\n        ? ReadonlyAccount<TAccountDevice>\n        : TAccountDevice,\n      TAccountDeviceMint extends string\n        ? WritableAccount<TAccountDeviceMint>\n        : TAccountDeviceMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateDeviceInstructionData = {\n  discriminator: number;\n  name: string;\n  uri: string;\n  additionalMetadata: Array<readonly [string, string]>;\n  signingAlg: DeviceSigningAlgorithm;\n};\n\nexport type CreateDeviceInstructionDataArgs = {\n  name: string;\n  uri: string;\n  additionalMetadata: Array<readonly [string, string]>;\n  signingAlg: DeviceSigningAlgorithmArgs;\n};\n\nexport function getCreateDeviceInstructionDataEncoder(): Encoder<CreateDeviceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      [\n        'additionalMetadata',\n        getArrayEncoder(\n          getTupleEncoder([\n            addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n            addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n          ])\n        ),\n      ],\n      ['signingAlg', getDeviceSigningAlgorithmEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: 2 })\n  );\n}\n\nexport function getCreateDeviceInstructionDataDecoder(): Decoder<CreateDeviceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    [\n      'additionalMetadata',\n      getArrayDecoder(\n        getTupleDecoder([\n          addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n          addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n        ])\n      ),\n    ],\n    ['signingAlg', getDeviceSigningAlgorithmDecoder()],\n  ]);\n}\n\nexport function getCreateDeviceInstructionDataCodec(): Codec<\n  CreateDeviceInstructionDataArgs,\n  CreateDeviceInstructionData\n> {\n  return combineCodec(\n    getCreateDeviceInstructionDataEncoder(),\n    getCreateDeviceInstructionDataDecoder()\n  );\n}\n\nexport type CreateDeviceInput<\n  TAccountSystemProgram extends string = string,\n  TAccountToken2022Program extends string = string,\n  TAccountAtaProgram extends string = string,\n  TAccountPayer extends string = string,\n  TAccountVendor extends string = string,\n  TAccountProductMint extends string = string,\n  TAccountProductAssociatedToken extends string = string,\n  TAccountDevice extends string = string,\n  TAccountDeviceMint extends string = string,\n> = {\n  /** The system program */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** The SPL Token 2022 program */\n  token2022Program: Address<TAccountToken2022Program>;\n  /** The associated token program */\n  ataProgram?: Address<TAccountAtaProgram>;\n  /** The account paying for the storage fees */\n  payer: TransactionSigner<TAccountPayer>;\n  /** The vendor */\n  vendor: TransactionSigner<TAccountVendor>;\n  /** The mint account of the product */\n  productMint: Address<TAccountProductMint>;\n  /** The associated token account of the product */\n  productAssociatedToken: Address<TAccountProductAssociatedToken>;\n  /** The device */\n  device: Address<TAccountDevice>;\n  /** The mint account of the device */\n  deviceMint: Address<TAccountDeviceMint>;\n  name: CreateDeviceInstructionDataArgs['name'];\n  uri: CreateDeviceInstructionDataArgs['uri'];\n  additionalMetadata: CreateDeviceInstructionDataArgs['additionalMetadata'];\n  signingAlg: CreateDeviceInstructionDataArgs['signingAlg'];\n};\n\nexport function getCreateDeviceInstruction<\n  TAccountSystemProgram extends string,\n  TAccountToken2022Program extends string,\n  TAccountAtaProgram extends string,\n  TAccountPayer extends string,\n  TAccountVendor extends string,\n  TAccountProductMint extends string,\n  TAccountProductAssociatedToken extends string,\n  TAccountDevice extends string,\n  TAccountDeviceMint extends string,\n>(\n  input: CreateDeviceInput<\n    TAccountSystemProgram,\n    TAccountToken2022Program,\n    TAccountAtaProgram,\n    TAccountPayer,\n    TAccountVendor,\n    TAccountProductMint,\n    TAccountProductAssociatedToken,\n    TAccountDevice,\n    TAccountDeviceMint\n  >\n): CreateDeviceInstruction<\n  typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountSystemProgram,\n  TAccountToken2022Program,\n  TAccountAtaProgram,\n  TAccountPayer,\n  TAccountVendor,\n  TAccountProductMint,\n  TAccountProductAssociatedToken,\n  TAccountDevice,\n  TAccountDeviceMint\n> {\n  // Program address.\n  const programAddress = DEPHY_ID_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    token2022Program: {\n      value: input.token2022Program ?? null,\n      isWritable: false,\n    },\n    ataProgram: { value: input.ataProgram ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    vendor: { value: input.vendor ?? null, isWritable: false },\n    productMint: { value: input.productMint ?? null, isWritable: true },\n    productAssociatedToken: {\n      value: input.productAssociatedToken ?? null,\n      isWritable: true,\n    },\n    device: { value: input.device ?? null, isWritable: false },\n    deviceMint: { value: input.deviceMint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.ataProgram.value) {\n    accounts.ataProgram.value =\n      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.token2022Program),\n      getAccountMeta(accounts.ataProgram),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.vendor),\n      getAccountMeta(accounts.productMint),\n      getAccountMeta(accounts.productAssociatedToken),\n      getAccountMeta(accounts.device),\n      getAccountMeta(accounts.deviceMint),\n    ],\n    programAddress,\n    data: getCreateDeviceInstructionDataEncoder().encode(\n      args as CreateDeviceInstructionDataArgs\n    ),\n  } as CreateDeviceInstruction<\n    typeof DEPHY_ID_PROGRAM_ADDRESS,\n    TAccountSystemProgram,\n    TAccountToken2022Program,\n    TAccountAtaProgram,\n    TAccountPayer,\n    TAccountVendor,\n    TAccountProductMint,\n    TAccountProductAssociatedToken,\n    TAccountDevice,\n    TAccountDeviceMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateDeviceInstruction<\n  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The system program */\n    systemProgram: TAccountMetas[0];\n    /** The SPL Token 2022 program */\n    token2022Program: TAccountMetas[1];\n    /** The associated token program */\n    ataProgram: TAccountMetas[2];\n    /** The account paying for the storage fees */\n    payer: TAccountMetas[3];\n    /** The vendor */\n    vendor: TAccountMetas[4];\n    /** The mint account of the product */\n    productMint: TAccountMetas[5];\n    /** The associated token account of the product */\n    productAssociatedToken: TAccountMetas[6];\n    /** The device */\n    device: TAccountMetas[7];\n    /** The mint account of the device */\n    deviceMint: TAccountMetas[8];\n  };\n  data: CreateDeviceInstructionData;\n};\n\nexport function parseCreateDeviceInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateDeviceInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 9) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      systemProgram: getNextAccount(),\n      token2022Program: getNextAccount(),\n      ataProgram: getNextAccount(),\n      payer: getNextAccount(),\n      vendor: getNextAccount(),\n      productMint: getNextAccount(),\n      productAssociatedToken: getNextAccount(),\n      device: getNextAccount(),\n      deviceMint: getNextAccount(),\n    },\n    data: getCreateDeviceInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  Address,\n  Codec,\n  Decoder,\n  Encoder,\n  IAccountMeta,\n  IAccountSignerMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n  ReadonlySignerAccount,\n  TransactionSigner,\n  WritableAccount,\n  WritableSignerAccount,\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n} from '@solana/web3.js';\nimport { DEPHY_ID_PROGRAM_ADDRESS } from '../programs';\nimport { ResolvedAccount, getAccountMetaFactory } from '../shared';\n\nexport type CreateProductInstruction<\n  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountToken2022Program extends string | IAccountMeta<string> = string,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountVendor extends string | IAccountMeta<string> = string,\n  TAccountProductMint extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountToken2022Program extends string\n        ? ReadonlyAccount<TAccountToken2022Program>\n        : TAccountToken2022Program,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountVendor extends string\n        ? ReadonlySignerAccount<TAccountVendor> &\n            IAccountSignerMeta<TAccountVendor>\n        : TAccountVendor,\n      TAccountProductMint extends string\n        ? WritableAccount<TAccountProductMint>\n        : TAccountProductMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateProductInstructionData = {\n  discriminator: number;\n  name: string;\n  symbol: string;\n  uri: string;\n  additionalMetadata: Array<readonly [string, string]>;\n};\n\nexport type CreateProductInstructionDataArgs = {\n  name: string;\n  symbol: string;\n  uri: string;\n  additionalMetadata: Array<readonly [string, string]>;\n};\n\nexport function getCreateProductInstructionDataEncoder(): Encoder<CreateProductInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      [\n        'additionalMetadata',\n        getArrayEncoder(\n          getTupleEncoder([\n            addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n            addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n          ])\n        ),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: 1 })\n  );\n}\n\nexport function getCreateProductInstructionDataDecoder(): Decoder<CreateProductInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    [\n      'additionalMetadata',\n      getArrayDecoder(\n        getTupleDecoder([\n          addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n          addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n        ])\n      ),\n    ],\n  ]);\n}\n\nexport function getCreateProductInstructionDataCodec(): Codec<\n  CreateProductInstructionDataArgs,\n  CreateProductInstructionData\n> {\n  return combineCodec(\n    getCreateProductInstructionDataEncoder(),\n    getCreateProductInstructionDataDecoder()\n  );\n}\n\nexport type CreateProductInput<\n  TAccountSystemProgram extends string = string,\n  TAccountToken2022Program extends string = string,\n  TAccountPayer extends string = string,\n  TAccountVendor extends string = string,\n  TAccountProductMint extends string = string,\n> = {\n  /** The system program */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** The SPL Token 2022 program */\n  token2022Program: Address<TAccountToken2022Program>;\n  /** The account paying for the storage fees */\n  payer: TransactionSigner<TAccountPayer>;\n  /** The vendor */\n  vendor: TransactionSigner<TAccountVendor>;\n  /** The mint account of the product */\n  productMint: Address<TAccountProductMint>;\n  name: CreateProductInstructionDataArgs['name'];\n  symbol: CreateProductInstructionDataArgs['symbol'];\n  uri: CreateProductInstructionDataArgs['uri'];\n  additionalMetadata: CreateProductInstructionDataArgs['additionalMetadata'];\n};\n\nexport function getCreateProductInstruction<\n  TAccountSystemProgram extends string,\n  TAccountToken2022Program extends string,\n  TAccountPayer extends string,\n  TAccountVendor extends string,\n  TAccountProductMint extends string,\n>(\n  input: CreateProductInput<\n    TAccountSystemProgram,\n    TAccountToken2022Program,\n    TAccountPayer,\n    TAccountVendor,\n    TAccountProductMint\n  >\n): CreateProductInstruction<\n  typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountSystemProgram,\n  TAccountToken2022Program,\n  TAccountPayer,\n  TAccountVendor,\n  TAccountProductMint\n> {\n  // Program address.\n  const programAddress = DEPHY_ID_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    token2022Program: {\n      value: input.token2022Program ?? null,\n      isWritable: false,\n    },\n    payer: { value: input.payer ?? null, isWritable: true },\n    vendor: { value: input.vendor ?? null, isWritable: false },\n    productMint: { value: input.productMint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.token2022Program),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.vendor),\n      getAccountMeta(accounts.productMint),\n    ],\n    programAddress,\n    data: getCreateProductInstructionDataEncoder().encode(\n      args as CreateProductInstructionDataArgs\n    ),\n  } as CreateProductInstruction<\n    typeof DEPHY_ID_PROGRAM_ADDRESS,\n    TAccountSystemProgram,\n    TAccountToken2022Program,\n    TAccountPayer,\n    TAccountVendor,\n    TAccountProductMint\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCreateProductInstruction<\n  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The system program */\n    systemProgram: TAccountMetas[0];\n    /** The SPL Token 2022 program */\n    token2022Program: TAccountMetas[1];\n    /** The account paying for the storage fees */\n    payer: TAccountMetas[2];\n    /** The vendor */\n    vendor: TAccountMetas[3];\n    /** The mint account of the product */\n    productMint: TAccountMetas[4];\n  };\n  data: CreateProductInstructionData;\n};\n\nexport function parseCreateProductInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateProductInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      systemProgram: getNextAccount(),\n      token2022Program: getNextAccount(),\n      payer: getNextAccount(),\n      vendor: getNextAccount(),\n      productMint: getNextAccount(),\n    },\n    data: getCreateProductInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the kinobi library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun kinobi to update it.\n *\n * @see https://github.com/kinobi-so/kinobi\n */\n\nimport {\n  Address,\n  Codec,\n  Decoder,\n  Encoder,\n  IAccountMeta,\n  IAccountSignerMeta,\n  IInstruction,\n  IInstructionWithAccounts,\n  IInstructionWithData,\n  ReadonlyAccount,\n  ReadonlySignerAccount,\n  TransactionSigner,\n  WritableAccount,\n  WritableSignerAccount,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n} from '@solana/web3.js';\nimport { DEPHY_ID_PROGRAM_ADDRESS } from '../programs';\nimport { ResolvedAccount, getAccountMetaFactory } from '../shared';\n\nexport type InitializeInstruction<\n  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountProgramData extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountProgramData extends string\n        ? WritableAccount<TAccountProgramData>\n        : TAccountProgramData,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeInstructionData = { discriminator: number; bump: number };\n\nexport type InitializeInstructionDataArgs = { bump: number };\n\nexport function getInitializeInstructionDataEncoder(): Encoder<InitializeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['bump', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: 0 })\n  );\n}\n\nexport function getInitializeInstructionDataDecoder(): Decoder<InitializeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['bump', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeInstructionDataCodec(): Codec<\n  InitializeInstructionDataArgs,\n  InitializeInstructionData\n> {\n  return combineCodec(\n    getInitializeInstructionDataEncoder(),\n    getInitializeInstructionDataDecoder()\n  );\n}\n\nexport type InitializeInput<\n  TAccountSystemProgram extends string = string,\n  TAccountPayer extends string = string,\n  TAccountProgramData extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The system program */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** The account paying for the storage fees */\n  payer: TransactionSigner<TAccountPayer>;\n  /** The program data account for the program */\n  programData: Address<TAccountProgramData>;\n  /** The authority account of the program */\n  authority: TransactionSigner<TAccountAuthority>;\n  bump: InitializeInstructionDataArgs['bump'];\n};\n\nexport function getInitializeInstruction<\n  TAccountSystemProgram extends string,\n  TAccountPayer extends string,\n  TAccountProgramData extends string,\n  TAccountAuthority extends string,\n>(\n  input: InitializeInput<\n    TAccountSystemProgram,\n    TAccountPayer,\n    TAccountProgramData,\n    TAccountAuthority\n  >\n): InitializeInstruction<\n  typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountSystemProgram,\n  TAccountPayer,\n  TAccountProgramData,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress = DEPHY_ID_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    programData: { value: input.programData ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.programData),\n      getAccountMeta(accounts.authority),\n    ],\n    programAddress,\n    data: getInitializeInstructionDataEncoder().encode(\n      args as InitializeInstructionDataArgs\n    ),\n  } as InitializeInstruction<\n    typeof DEPHY_ID_PROGRAM_ADDRESS,\n    TAccountSystemProgram,\n    TAccountPayer,\n    TAccountProgramData,\n    TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeInstruction<\n  TProgram extends string = typeof DEPHY_ID_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The system program */\n    systemProgram: TAccountMetas[0];\n    /** The account paying for the storage fees */\n    payer: TAccountMetas[1];\n    /** The program data account for the program */\n    programData: TAccountMetas[2];\n    /** The authority account of the program */\n    authority: TAccountMetas[3];\n  };\n  data: InitializeInstructionData;\n};\n\nexport function parseInitializeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      systemProgram: getNextAccount(),\n      payer: getNextAccount(),\n      programData: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getInitializeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n"]}